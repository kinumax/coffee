<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PeerJS WebRTC App</title>
    <meta name="description" content="PeerJS WebRTC Minimal App with integrated features.">

    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>📞</text></svg>">

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <style>
        /* カスタムCSSは最小限に */
        body {
            font-family: sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #localAudio, #remoteAudio {
            display: none; /* Audio elements are typically hidden */
        }
        .peer-id-box {
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
            cursor: copy;
        }
        .recording-pulse {
            animation: pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .connection-status-message {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen">
    <div id="app" class="container bg-white">
        <h1 class="text-3xl font-bold text-center text-blue-700 mb-6 flex items-center justify-center space-x-2">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            PeerJS 音声通話アプリ
        </h1>

        <div id="connectionStatus" class="connection-status-message p-3 mb-4 rounded-lg text-sm flex items-center space-x-2">
            <svg id="statusIcon" class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            <p id="statusText">未接続</p>
        </div>

        <div class="space-y-6">
            <div class="bg-blue-50 border border-blue-200 p-4 rounded-lg shadow-sm text-center">
                <p class="text-blue-700 text-sm mb-2">あなたのPeer ID:</p>
                <div class="flex items-center justify-center space-x-2">
                    <span id="myPeerId" class="peer-id-box bg-blue-100 text-blue-800 px-4 py-2 rounded-md text-lg font-semibold select-all" onclick="copyToClipboard(this.textContent)">ID生成中...</span>
                    <button id="copyIdButton" class="bg-blue-600 hover:bg-blue-700 text-white p-2 rounded-full shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"/></svg>
                    </button>
                </div>
                <p class="text-gray-600 text-xs mt-2">このIDを相手に伝えてください。</p>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <button id="hostButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-green-500 transition-all flex items-center justify-center space-x-2 text-lg">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/></svg>
                    <span>ホストになる</span>
                </button>

                <div class="flex flex-col space-y-2">
                    <input type="text" id="targetPeerIdInput" placeholder="相手のPeer IDを入力" class="p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-base">
                    <button id="connectButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all flex items-center justify-center space-x-2 text-lg">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z"/></svg>
                        <span>相手に接続する</span>
                    </button>
                </div>
            </div>

            <div id="callControls" class="bg-gray-50 border border-gray-200 p-4 rounded-lg shadow-sm text-center hidden">
                <p class="text-gray-700 text-sm mb-2" id="callStatusText"></p>
                <div class="flex items-center justify-center space-x-4 mb-4">
                    <div id="recordingPulse" class="w-4 h-4 bg-red-500 rounded-full recording-pulse hidden"></div>
                    <div class="text-4xl font-bold text-gray-900" id="recordingTime">0:00</div>
                </div>
                <button id="endCallButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-red-500 transition-all flex items-center justify-center space-x-2 text-lg w-full">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16.72 11.06A10.94 10.94 0 0119 12.55a1 1 0 01-.051 1.81l-4.494 1.498a1 1 0 01-1.21-.502l-1.13-2.257M16.72 11.06l-1.475 1.475M16.72 11.06L21 6.78m-4.28 4.28L12 6.34m3.72 4.72l-3.72-4.72m0 0L5.78 1.22 4.36 2.64l14.142 14.142 1.415-1.414L11.06 6.34z"/></svg>
                    <span>通話を終了</span>
                </button>
            </div>

            <div class="bg-white border border-gray-200 p-4 rounded-lg shadow-sm">
                <h2 class="text-xl font-bold text-gray-800 mb-4 text-center">チャット</h2>
                <div id="messages" class="h-60 overflow-y-auto border border-gray-300 p-3 rounded-lg bg-gray-50 mb-4 text-gray-700 text-sm leading-relaxed">
                    </div>
                <div class="flex space-x-2">
                    <input type="text" id="messageInput" placeholder="メッセージを入力..." class="flex-1 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-base">
                    <button id="sendMessageButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                        送信
                    </button>
                </div>
            </div>
        </div>

        <audio id="localAudio" autoplay muted></audio>
        <audio id="remoteAudio" autoplay></audio>
    </div>

    <script>
        // DOM要素の取得
        const myPeerIdEl = document.getElementById('myPeerId');
        const copyIdButton = document.getElementById('copyIdButton');
        const targetPeerIdInput = document.getElementById('targetPeerIdInput');
        const hostButton = document.getElementById('hostButton');
        const connectButton = document.getElementById('connectButton');
        const endCallButton = document.getElementById('endCallButton');
        const localAudio = document.getElementById('localAudio');
        const remoteAudio = document.getElementById('remoteAudio');
        const messageInput = document.getElementById('messageInput');
        const sendMessageButton = document.getElementById('sendMessageButton');
        const messagesDiv = document.getElementById('messages');
        const callControls = document.getElementById('callControls');
        const recordingTimeEl = document.getElementById('recordingTime');
        const recordingPulseEl = document.getElementById('recordingPulse');
        const connectionStatusDiv = document.getElementById('connectionStatus');
        const statusIcon = document.getElementById('statusIcon');
        const statusText = document.getElementById('statusText');
        const callStatusText = document.getElementById('callStatusText');

        // アプリケーションの状態
        const AppState = {
            peer: null,
            myPeerId: '',
            remotePeerId: '',
            isConnected: false,
            isHost: false,
            isGuest: false,
            audioStream: null,
            currentCall: null,
            dataConnection: null, // PeerJS DataConnection用
            recordingTime: 0,
            recordingTimer: null,
            // disconnected, connecting, connected, error
            connectionStatus: 'disconnected'
        };

        // PeerJSサーバーの設定
        const PEER_SERVER_CONFIG = {
            host: 'localhost',
            port: 9000,
            path: '/myapp',
            config: {
                'iceServers': [
                    { 'urls': 'stun:stun.l.google.com:19302' } // NAT越えのためのSTUNサーバー
                ]
            }
        };

        // UI更新関数
        function updateUI() {
            myPeerIdEl.textContent = AppState.myPeerId || 'ID生成中...';
            targetPeerIdInput.value = AppState.remotePeerId;

            hostButton.disabled = AppState.isConnected || AppState.connectionStatus === 'connecting';
            targetPeerIdInput.disabled = AppState.isConnected || AppState.connectionStatus === 'connecting';
            connectButton.disabled = AppState.isConnected || AppState.connectionStatus === 'connecting';
            sendMessageButton.disabled = !AppState.isConnected || !AppState.dataConnection || !AppState.dataConnection.open;
            messageInput.disabled = !AppState.isConnected || !AppState.dataConnection || !AppState.dataConnection.open;

            if (AppState.isConnected) {
                callControls.classList.remove('hidden');
                hostButton.classList.add('hidden');
                document.querySelector('.grid.grid-cols-1.md\\:grid-cols-2').classList.add('hidden'); // ホスト/ゲスト選択を隠す
                if (AppState.isHost) {
                    callStatusText.textContent = `ホストとして '${AppState.remotePeerId}' と通話中`;
                    recordingPulseEl.classList.remove('hidden');
                } else if (AppState.isGuest) {
                    callStatusText.textContent = `'${AppState.remotePeerId}' と通話中`;
                    recordingPulseEl.classList.add('hidden'); // ゲストは録画パルスを表示しない
                }
            } else {
                callControls.classList.add('hidden');
                hostButton.classList.remove('hidden');
                document.querySelector('.grid.grid-cols-1.md\\:grid-cols-2').classList.remove('hidden');
                recordingPulseEl.classList.add('hidden');
            }

            // 接続ステータスの表示更新
            connectionStatusDiv.className = 'connection-status-message p-3 mb-4 rounded-lg text-sm flex items-center space-x-2';
            switch (AppState.connectionStatus) {
                case 'disconnected':
                    connectionStatusDiv.classList.add('bg-blue-50', 'border-blue-200', 'text-blue-800');
                    statusIcon.innerHTML = `<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                    statusText.textContent = '未接続';
                    break;
                case 'connecting':
                    connectionStatusDiv.classList.add('bg-yellow-50', 'border-yellow-200', 'text-yellow-800');
                    statusIcon.innerHTML = `<svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
                    statusText.textContent = '接続中...';
                    break;
                case 'connected':
                    connectionStatusDiv.classList.add('bg-green-50', 'border-green-200', 'text-green-800');
                    statusIcon.innerHTML = `<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/></svg>`;
                    statusText.textContent = `接続済み${AppState.remotePeerId ? `: ${AppState.remotePeerId}` : ''}`;
                    break;
                case 'error':
                    connectionStatusDiv.classList.add('bg-red-50', 'border-red-200', 'text-red-800');
                    statusIcon.innerHTML = `<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                    statusText.textContent = 'エラーが発生しました。';
                    break;
            }
        }

        // メッセージを画面に表示するヘルパー関数
        function appendMessage(text, sender = 'システム') {
            const p = document.createElement('p');
            p.textContent = `${sender}: ${text}`;
            messagesDiv.appendChild(p);
            messagesDiv.scrollTop = messagesDiv.scrollHeight; // スクロールを一番下へ
        }

        // 時間フォーマット
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // トースト通知
        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-lg z-50 transition-opacity duration-300 opacity-0';
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '1';
            }, 10); // 短い遅延でトランジションを有効化

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.addEventListener('transitionend', () => toast.remove());
            }, 2000);
        }

        // PeerJS初期化
        function initializePeer(id = null) {
            if (AppState.peer) {
                AppState.peer.destroy();
                AppState.peer = null;
            }
            AppState.peer = new Peer(id, PEER_SERVER_CONFIG);

            AppState.peer.on('open', (newId) => {
                AppState.myPeerId = newId;
                AppState.connectionStatus = 'disconnected'; // PeerJSサーバーへの接続は完了したが、P2P接続は未確立
                console.log('Peer ID:', newId);
                updateUI();
            });

            AppState.peer.on('error', (err) => {
                console.error('PeerJSエラー:', err);
                AppState.connectionStatus = 'error';
                appendMessage(`エラー: ${err.message || err.type}`, 'PeerJS');
                if (err.type === 'peer-unavailable') {
                    appendMessage('指定されたPeer IDが見つかりません。相手がオンラインで、IDが正しいか確認してください。');
                } else if (err.type === 'network') {
                    appendMessage('ネットワーク接続の問題です。インターネット接続またはサーバーを確認してください。');
                } else if (err.type === 'disconnected') {
                     // サーバーから切断された場合は、再接続を促す
                    appendMessage('PeerJSサーバーから切断されました。');
                }
                updateUI();
            });

            AppState.peer.on('close', () => {
                console.log('PeerJS接続が閉じられました。');
                AppState.connectionStatus = 'disconnected';
                updateUI();
            });

            AppState.peer.on('disconnected', () => {
                console.log('PeerJSサーバーから切断されました。');
                AppState.connectionStatus = 'disconnected';
                updateUI();
                // 必要であればここで自動再接続ロジックを実装
            });

            // ゲストからのデータ接続があった時 (ホスト側が受信)
            AppState.peer.on('connection', (conn) => {
                console.log(`'${conn.peer}' からデータ接続がありました。`);
                appendMessage(`'${conn.peer}' からデータ接続要求。`);
                setupDataConnectionEvents(conn);
            });

            // ゲストからのメディア接続 (音声) があった時 (ホスト側が受信)
            AppState.peer.on('call', (call) => {
                if (!AppState.isHost) {
                    console.log('ホストではないため、着信を拒否します。');
                    call.close();
                    appendMessage(`ゲストからの接続を拒否しました。あなたはホストではありません。`);
                    return;
                }
                console.log(`'${call.peer}' からメディア接続がありました。`);
                appendMessage(`'${call.peer}' からメディア接続要求。`);

                if (AppState.audioStream) {
                    call.answer(AppState.audioStream); // 自分のストリームを送信して応答
                    AppState.currentCall = call; // 現在の通話を保持
                    AppState.remotePeerId = call.peer;
                    setupMediaCallEvents(call);
                    AppState.isConnected = true;
                    AppState.connectionStatus = 'connected';
                    appendMessage(`'${call.peer}' と通話開始。`, 'システム');
                } else {
                    console.error('オーディオストリームが利用できません。');
                    appendMessage('オーディオストリームが利用できません。ホストを開始してから再試行してください。');
                    call.close();
                }
                updateUI();
            });
        }

        // データ接続イベントのセットアップ
        function setupDataConnectionEvents(conn) {
            // 既存のデータ接続があればクローズ
            if (AppState.dataConnection) {
                AppState.dataConnection.close();
            }
            AppState.dataConnection = conn;

            conn.on('open', () => {
                console.log(`'${conn.peer}' とのデータ接続が確立されました。`);
                // データ接続確立後、UIを更新
                updateUI();
            });

            conn.on('data', (data) => {
                console.log(`'${conn.peer}' からデータを受信:`, data);
                appendMessage(data, conn.peer);
            });

            conn.on('close', () => {
                console.log(`'${conn.peer}' とのデータ接続が閉じられました。`);
                AppState.dataConnection = null;
                // データ接続が閉じられても、メディア接続が続いている場合がある
                if (!AppState.currentCall || AppState.currentCall.open === false) {
                     endCall(); // 両方閉じていれば完全終了
                }
                updateUI();
            });

            conn.on('error', (err) => {
                console.error(`'${conn.peer}' とのデータ接続エラー:`, err);
                appendMessage(`データ接続エラー: ${err.message}`, '接続');
            });
        }

        // メディア通話イベントのセットアップ
        function setupMediaCallEvents(call) {
            call.on('stream', (remoteStream) => {
                console.log('相手のメディアストリームを受信。');
                remoteAudio.srcObject = remoteStream; // 相手のストリームを再生
                remoteAudio.play().catch(e => console.warn("Remote audio playback failed:", e));
            });

            call.on('close', () => {
                console.log('メディア接続が閉じられました。');
                remoteAudio.srcObject = null;
                // メディア接続が閉じられても、データ接続が続いている場合がある
                if (!AppState.dataConnection || AppState.dataConnection.open === false) {
                    endCall(); // 両方閉じていれば完全終了
                }
                updateUI();
            });

            call.on('error', (err) => {
                console.error('メディア接続エラー:', err);
                appendMessage(`メディア接続エラー: ${err.message}`, 'メディア');
            });
        }

        // ホストになる
        async function startHosting() {
            try {
                AppState.connectionStatus = 'connecting';
                updateUI();
                appendMessage('マイクへのアクセスを要求しています...');

                AppState.audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 44100
                    }
                });

                localAudio.srcObject = AppState.audioStream; // 自分の音声をモニター（muted）
                localAudio.play().catch(e => console.warn("Local audio playback failed:", e));

                initializePeer(); // IDを自動生成させる

                AppState.peer.on('open', (id) => {
                    AppState.isHost = true;
                    AppState.isConnected = false; // まだゲストとは繋がっていない
                    AppState.remotePeerId = '';
                    AppState.connectionStatus = 'connected'; // PeerJSサーバーに接続済み
                    appendMessage(`ホストとして待機中。あなたのID: ${id}`);
                    startRecordingTimer();
                    updateUI();
                });

            } catch (error) {
                console.error('ホスト開始エラー:', error);
                AppState.connectionStatus = 'error';
                appendMessage(`ホスト開始エラー: マイクへのアクセスを許可してください (${error.message})`, 'エラー');
                updateUI();
            }
        }

        // 相手に接続する
        async function connectToHost() {
            const targetPeerId = targetPeerIdInput.value.trim();
            if (!targetPeerId) {
                showToast('相手のPeer IDを入力してください！');
                return;
            }

            AppState.connectionStatus = 'connecting';
            AppState.remotePeerId = targetPeerId;
            updateUI();
            appendMessage(`'${targetPeerId}' への接続を試みています...`);
            appendMessage('マイクへのアクセスを要求しています...');

            try {
                AppState.audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 44100
                    }
                });
                localAudio.srcObject = AppState.audioStream; // 自分の音声をモニター（muted）
                localAudio.play().catch(e => console.warn("Local audio playback failed:", e));

                // ホスト側とは異なり、接続側はIDを自動生成して初期化
                initializePeer();

                AppState.peer.on('open', () => {
                    // データ接続を開始
                    const dataConn = AppState.peer.connect(targetPeerId);
                    setupDataConnectionEvents(dataConn);

                    // メディア接続（音声通話）を開始
                    const mediaCall = AppState.peer.call(targetPeerId, AppState.audioStream);
                    AppState.currentCall = mediaCall; // 現在の通話を保持
                    AppState.isGuest = true;
                    AppState.isConnected = true;
                    AppState.connectionStatus = 'connected';
                    setupMediaCallEvents(mediaCall); // MediaConnectionイベントを設定
                    appendMessage(`'${targetPeerId}' に接続しました。`, 'システム');
                    updateUI();
                });

            } catch (error) {
                console.error('接続エラー:', error);
                AppState.connectionStatus = 'error';
                appendMessage(`接続エラー: マイクへのアクセスを許可してください (${error.message})`, 'エラー');
                updateUI();
            }
        }

        // 通話終了
        function endCall() {
            if (AppState.currentCall) {
                AppState.currentCall.close();
            }
            if (AppState.dataConnection) {
                AppState.dataConnection.close();
            }

            if (AppState.audioStream) {
                AppState.audioStream.getTracks().forEach(track => track.stop());
                AppState.audioStream = null;
            }

            localAudio.srcObject = null;
            remoteAudio.srcObject = null;

            if (AppState.recordingTimer) {
                clearInterval(AppState.recordingTimer);
                AppState.recordingTimer = null;
            }

            AppState.isConnected = false;
            AppState.isHost = false;
            AppState.isGuest = false;
            AppState.remotePeerId = '';
            AppState.currentCall = null;
            AppState.dataConnection = null;
            AppState.connectionStatus = 'disconnected';

            appendMessage('通話が終了しました。', 'システム');
            updateUI();
        }

        // 録音タイマー開始 (ホスト側のみ)
        function startRecordingTimer() {
            AppState.recordingTime = 0;
            if (AppState.recordingTimer) clearInterval(AppState.recordingTimer); // 既存のタイマーがあればクリア
            AppState.recordingTimer = setInterval(() => {
                AppState.recordingTime++;
                recordingTimeEl.textContent = formatTime(AppState.recordingTime);
            }, 1000);
        }

        // --- イベントリスナー ---
        hostButton.addEventListener('click', startHosting);
        connectButton.addEventListener('click', connectToHost);
        endCallButton.addEventListener('click', endCall);

        sendMessageButton.addEventListener('click', () => {
            if (AppState.dataConnection && AppState.dataConnection.open) {
                const message = messageInput.value.trim();
                if (message) {
                    AppState.dataConnection.send(message);
                    appendMessage(message, 'あなた');
                    messageInput.value = '';
                }
            } else {
                showToast('チャット接続が確立されていません。');
            }
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessageButton.click();
            }
        });

        copyIdButton.addEventListener('click', () => {
            copyToClipboard(myPeerIdEl.textContent);
        });

        // ページ読み込み時にPeerJSインスタンスを初期化（IDは後で自動生成または指定）
        // PeerJSサーバーへの接続自体は最初に行う
        initializePeer();
        updateUI(); // 初期UI表示

        // 初回メッセージ
        appendMessage('リアルタイム通話を開始するには、「ホストになる」か、相手のIDを入力して「相手に接続する」を選択してください。', 'システム');

    </script>
</body>
</html>
